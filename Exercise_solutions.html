<!doctypehtml><html class="sidebar-visible no-js light"lang=en><head><meta charset=UTF-8><title>Exercise Solutions - CLI text processing with GNU sed</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta content="Example based guide to mastering GNU sed"name=description><meta content=width=device-width,initial-scale=1 name=viewport><meta content=#ffffff name=theme-color><meta content="CLI text processing with GNU sed"property=og:title><meta content=website property=og:type><meta content="Example based guide to mastering GNU sed"property=og:description><meta content=https://learnbyexample.github.io/learn_gnused/ property=og:url><meta content=https://raw.githubusercontent.com/learnbyexample/learn_gnused/master/images/sed_ls.png property=og:image><meta content=1280 property=og:image:width><meta content=720 property=og:image:height><meta content=summary_large_image property=twitter:card><meta content=@learn_byexample property=twitter:site><link href=favicon.svg rel=icon><link rel="shortcut icon"href=favicon.png><link href=css/variables.css rel=stylesheet><link href=css/general.css rel=stylesheet><link href=css/chrome.css rel=stylesheet><link href=FontAwesome/css/font-awesome.css rel=stylesheet><link href=fonts/fonts.css rel=stylesheet><link href=highlight.css rel=stylesheet><link href=tomorrow-night.css rel=stylesheet><link href=ayu-highlight.css rel=stylesheet><link href=style.css rel=stylesheet><body><script>var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";</script><script>try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }</script><script>var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');</script><script>var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);</script><nav aria-label="Table of contents"class=sidebar id=sidebar><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>2.</strong> Introduction</a><li class="chapter-item expanded"><a href=in-place-file-editing.html><strong aria-hidden=true>3.</strong> In-place file editing</a><li class="chapter-item expanded"><a href=selective-editing.html><strong aria-hidden=true>4.</strong> Selective editing</a><li class="chapter-item expanded"><a href=breere-regular-expressions.html><strong aria-hidden=true>5.</strong> BRE/ERE Regular Expressions</a><li class="chapter-item expanded"><a href=flags.html><strong aria-hidden=true>6.</strong> Flags</a><li class="chapter-item expanded"><a href=shell-substitutions.html><strong aria-hidden=true>7.</strong> Shell substitutions</a><li class="chapter-item expanded"><a href=z-s-and-f-command-line-options.html><strong aria-hidden=true>8.</strong> z, s and f command line options</a><li class="chapter-item expanded"><a href=append-change-insert.html><strong aria-hidden=true>9.</strong> append, change, insert</a><li class="chapter-item expanded"><a href=adding-content-from-file.html><strong aria-hidden=true>10.</strong> Adding content from file</a><li class="chapter-item expanded"><a href=control-structures.html><strong aria-hidden=true>11.</strong> Control structures</a><li class="chapter-item expanded"><a href=processing-lines-bounded-by-distinct-markers.html><strong aria-hidden=true>12.</strong> Processing lines bounded by distinct markers</a><li class="chapter-item expanded"><a href=gotchas-and-tricks.html><strong aria-hidden=true>13.</strong> Gotchas and Tricks</a><li class="chapter-item expanded"><a href=further-reading.html><strong aria-hidden=true>14.</strong> Further Reading</a><li class="chapter-item expanded"><a class=active href=Exercise_solutions.html><strong aria-hidden=true>15.</strong> Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i class="fa fa-github"id=git-repository-button></i><a href=https://github.com/learnbyexample/learn_gnused>   Source code</a><li class="chapter-item expanded"><i class="fa fa-home"id=home-button></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i class="fa fa-book"id=book-button></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i class="fa fa-envelope"id=mail-button></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a><li class="chapter-item expanded"><i class="fa fa-twitter"id=twitter-button></i><a href=https://twitter.com/learn_byexample>   Twitter</a></ol></div><div class=sidebar-resize-handle id=sidebar-resize-handle></div></nav><div class=page-wrapper id=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div class="menu-bar sticky bordered"id=menu-bar><div class=left-buttons><button aria-label="Toggle Table of Contents"title="Toggle Table of Contents"aria-controls=sidebar class=icon-button id=sidebar-toggle type=button><i class="fa fa-bars"></i></button><button aria-label="Change theme"title="Change theme"aria-controls=theme-list aria-expanded=false aria-haspopup=true class=icon-button id=theme-toggle type=button><i class="fa fa-paint-brush"></i></button><ul aria-label=Themes class=theme-popup id=theme-list role=menu><li role=none><button class=theme id=light role=menuitem>Light (default)</button><li role=none><button class=theme id=rust role=menuitem>Rust</button><li role=none><button class=theme id=coal role=menuitem>Coal</button><li role=none><button class=theme id=navy role=menuitem>Navy</button><li role=none><button class=theme id=ayu role=menuitem>Ayu</button></ul><button aria-label="Toggle Searchbar"title="Search. (Shortkey: s)"aria-controls=searchbar aria-expanded=false aria-keyshortcuts=S class=icon-button id=search-toggle type=button><i class="fa fa-search"></i></button></div><h1 class=menu-title>CLI text processing with GNU sed</h1><div class=right-buttons><a aria-label=Blog href=https://learnbyexample.github.io title=Blog> <i class="fa fa-home"id=home-button></i> </a><a aria-label=Twitter href=https://twitter.com/learn_byexample title=Twitter> <i class="fa fa-twitter"id=twitter-button></i> </a><a aria-label="Git repository"title="Git repository"href=https://github.com/learnbyexample/learn_gnused> <i class="fa fa-github"id=git-repository-button></i> </a></div></div><div class=hidden id=search-wrapper><form class=searchbar-outer id=searchbar-outer><input placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header id=searchbar name=searchbar type=search></form><div class="searchresults-outer hidden"id=searchresults-outer><div class=searchresults-header id=searchresults-header></div><ul id=searchresults></ul></div></div><script>document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });</script><div class=content id=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=exercise-solutions><a class=header href=#exercise-solutions>Exercise solutions</a></h1><br><h1 id=introduction><a class=header href=#introduction>Introduction</a></h1><p><strong>1)</strong> Replace only the first occurrence of <code>5</code> with <code>five</code> for the given stdin source.<pre><code class=language-bash>$ echo 'They ate 5 apples and 5 mangoes' | sed 's/5/five/'
They ate five apples and 5 mangoes
</code></pre><p><strong>2)</strong> Replace all occurrences of <code>5</code> with <code>five</code>.<pre><code class=language-bash>$ echo 'They ate 5 apples and 5 mangoes' | sed 's/5/five/g'
They ate five apples and five mangoes
</code></pre><p><strong>3)</strong> Replace all occurrences of <code>0xA0</code> with <code>0x50</code> and <code>0xFF</code> with <code>0x7F</code> for the given input file.<pre><code class=language-bash>$ cat hex.txt
start address: 0xA0, func1 address: 0xA0
end address: 0xFF, func2 address: 0xB0

# if you already know how to specify multiple commands,
# a better solution would be: sed 's/0xA0/0x50/g; s/0xFF/0x7F/g' hex.txt
$ sed 's/0xA0/0x50/g' hex.txt | sed 's/0xFF/0x7F/g'
start address: 0x50, func1 address: 0x50
end address: 0x7F, func2 address: 0xB0
</code></pre><p><strong>4)</strong> The substitute command searches and replaces sequences of characters. When you need to map one or more characters with another set of corresponding characters, you can use the <code>y</code> command. Quoting from the manual:<blockquote><p><strong>y/src/dst/</strong> Transliterate any characters in the pattern space which match any of the source-chars with the corresponding character in dest-chars.</blockquote><p>Use the <code>y</code> command to transform the given input string to get the output string as shown below.<pre><code class=language-bash>$ echo 'goal new user sit eat dinner' | sed 'y/aeiou/AEIOU/'
gOAl nEw UsEr sIt EAt dInnEr
</code></pre><p><strong>5)</strong> Why does the following command produce an error? How'd you fix it?<p>Space is a shell metacharacter and thus you need to quote the <code>sed</code> script to avoid getting interpreted by the shell.<pre><code class=language-bash>$ echo 'a sunny day' | sed s/sunny day/cloudy day/
sed: -e expression #1, char 7: unterminated `s' command

# expected output
$ echo 'a sunny day' | sed 's/sunny day/cloudy day/'
a cloudy day
</code></pre><br><h1 id=in-place-file-editing><a class=header href=#in-place-file-editing>In-place file editing</a></h1><p><strong>1)</strong> For the input file <code>text.txt</code>, replace all occurrences of <code>in</code> with <code>an</code> and write back the changes to <code>text.txt</code> itself. The original contents should get saved to <code>text.txt.orig</code><pre><code class=language-bash>$ cat text.txt
can ran want plant
tin fin fit mine line
$ sed -i.orig 's/in/an/g' text.txt

$ cat text.txt
can ran want plant
tan fan fit mane lane
$ cat text.txt.orig
can ran want plant
tin fin fit mine line
</code></pre><p><strong>2)</strong> For the input file <code>text.txt</code>, replace all occurrences of <code>an</code> with <code>in</code> and write back the changes to <code>text.txt</code> itself. Do not create backups for this exercise. Note that you should have solved the previous exercise before starting this one.<pre><code class=language-bash>$ cat text.txt
can ran want plant
tan fan fit mane lane
$ sed -i 's/an/in/g' text.txt

$ cat text.txt
cin rin wint plint
tin fin fit mine line
$ diff text.txt text.txt.orig
1c1
< cin rin wint plint
---
> can ran want plant
</code></pre><p><strong>3)</strong> For the input file <code>copyright.txt</code>, replace <code>copyright: 2018</code> with <code>copyright: 2019</code> and write back the changes to <code>copyright.txt</code> itself. The original contents should get saved to <code>2018_copyright.txt.bkp</code><pre><code class=language-bash>$ cat copyright.txt
bla bla 2015 bla
blah 2018 blah
bla bla bla
copyright: 2018
$ sed -i'2018_*.bkp' 's/copyright: 2018/copyright: 2019/' copyright.txt

$ cat copyright.txt
bla bla 2015 bla
blah 2018 blah
bla bla bla
copyright: 2019
$ cat 2018_copyright.txt.bkp
bla bla 2015 bla
blah 2018 blah
bla bla bla
copyright: 2018
</code></pre><p><strong>4)</strong> In the code sample shown below, two files are created by redirecting the output of the <code>echo</code> command. Then a <code>sed</code> command is used to edit <code>b1.txt</code> in-place as well as create a backup named <code>bkp.b1.txt</code>. Will the <code>sed</code> command work as expected? If not, why?<pre><code class=language-bash>$ echo '2 apples' > b1.txt
$ echo '5 bananas' > -ibkp.txt
$ sed -ibkp.* 's/2/two/' b1.txt
</code></pre><p>Unquoted strings on the command line are subjected to shell interpretation. So, <code>-ibkp.*</code> will get expanded as <code>-ibkp.txt</code> (as there exists a file whose name starts with <code>-ibkp.</code>). This results in back up filename as <code>b1.txtbkp.txt</code> (because <code>bkp.txt</code> will be treated as the suffix to be added to <code>b1.txt</code>). The correct usage is <code>sed -i'bkp.*' 's/2/two/' b1.txt</code> to get <code>bkp.b1.txt</code> as the back up filename.<p><strong>5)</strong> For the input file <code>pets.txt</code>, remove the first occurrence of <code>I like </code> from each line and write back the changes to <code>pets.txt</code> itself. The original contents should get saved with the same filename inside the <code>bkp</code> directory. Assume that you do not know whether <code>bkp</code> exists or not in the current working directory.<pre><code class=language-bash>$ cat pets.txt
I like cats
I like parrots
I like dogs

$ mkdir -p bkp
$ sed -i'bkp/*' 's/I like //' pets.txt

$ cat pets.txt
cats
parrots
dogs
$ cat bkp/pets.txt
I like cats
I like parrots
I like dogs
</code></pre><br><h1 id=selective-editing><a class=header href=#selective-editing>Selective editing</a></h1><p><strong>1)</strong> For the given input, display except the third line.<pre><code class=language-bash>$ seq 34 37 | sed '3d'
34
35
37
</code></pre><p><strong>2)</strong> Display only the fourth, fifth, sixth and seventh lines for the given input.<pre><code class=language-bash>$ seq 65 78 | sed -n '4,7p'
68
69
70
71
</code></pre><p><strong>3)</strong> For the input file <code>addr.txt</code>, replace all occurrences of <code>are</code> with <code>are not</code> and <code>is</code> with <code>is not</code> only from line number <strong>4</strong> till the end of file. Also, only the lines that were changed should be displayed in the output.<pre><code class=language-bash>$ cat addr.txt
Hello World
How are you
This game is good
Today is sunny
12345
You are funny

$ sed -n '4,$ {s/are/are not/gp; s/is/is not/gp}' addr.txt
Today is not sunny
You are not funny
</code></pre><p><strong>4)</strong> Use <code>sed</code> to get the output shown below for the given input. You'll have to first understand the input to output transformation logic and then use commands introduced in this chapter to construct a solution.<pre><code class=language-bash># can also use: sed -n '2~5{p; n; n; p}'
$ seq 15 | sed -n 'n; p; n; n; p; n'
2
4
7
9
12
14
</code></pre><p><strong>5)</strong> For the input file <code>addr.txt</code>, display all lines from the start of the file till the first occurrence of <code>is</code>.<pre><code class=language-bash>$ sed '/is/q' addr.txt
Hello World
How are you
This game is good
</code></pre><p><strong>6)</strong> For the input file <code>addr.txt</code>, display all lines that contain <code>is</code> but not <code>good</code>.<pre><code class=language-bash>$ sed -n '/is/{/good/!p}' addr.txt
Today is sunny
</code></pre><p><strong>7)</strong> <code>n</code> and <code>N</code> commands will not execute further commands if there are no more input lines to fetch. Correct the command shown below to get the expected output.<pre><code class=language-bash># wrong output
$ seq 11 | sed 'N; N; s/\n/-/g'
1-2-3
4-5-6
7-8-9
10
11

# expected output
# can also use: sed 'N; $!N; s/\n/-/g'
$ seq 11 | sed 'N; $!N; y/\n/-/'
1-2-3
4-5-6
7-8-9
10-11
</code></pre><p><strong>8)</strong> For the input file <code>addr.txt</code>, add line numbers in the format as shown below.<pre><code class=language-bash>$ sed '=' addr.txt
1
Hello World
2
How are you
3
This game is good
4
Today is sunny
5
12345
6
You are funny
</code></pre><p><strong>9)</strong> For the input file <code>addr.txt</code>, print all lines that contain <code>are</code> and the line that comes after, if any.<pre><code class=language-bash>$ sed -n '/are/,+1 p' addr.txt
How are you
This game is good
You are funny
</code></pre><p><strong>Bonus:</strong> For the above input file, will <code>sed -n '/is/,+1 p' addr.txt</code> produce identical results as <code>grep -A1 'is' addr.txt</code>? If not, why?<p>No. <code>sed</code> will not try to match <code>is</code> in the context lines whereas <code>grep</code> will match the search term in the context lines as well. Also, in general, you'll need to use the <code>--no-group-separator</code> option to prevent <code>grep</code> from adding a separator between the different matching groups.<p><strong>10)</strong> Print all lines if their line numbers follow the sequence 1, 15, 29, 43, etc but not if the line contains <code>4</code> in it.<pre><code class=language-bash>$ seq 32 100 | sed -n '1~14 {/4/!p}'
32
60
88
</code></pre><p><strong>11)</strong> For the input file <code>sample.txt</code>, display from the start of the file till the first occurrence of <code>are</code>, excluding the matching line.<pre><code class=language-bash>$ cat sample.txt
Hello World

Hi there
How are you

Just do-it
Believe it

banana
papaya
mango

Much ado about nothing
He he he
Adios amigo

$ sed '/are/Q' sample.txt
Hello World

Hi there
</code></pre><p><strong>12)</strong> For the input file <code>sample.txt</code>, display from the last occurrence of <code>do</code> till the end of the file.<pre><code class=language-bash>$ tac sample.txt | sed '/do/q' | tac
Much ado about nothing
He he he
Adios amigo
</code></pre><p><strong>13)</strong> For the input file <code>sample.txt</code>, display from the 9th line till a line containing <code>go</code>.<pre><code class=language-bash>$ sed -n '9,/go/p' sample.txt
banana
papaya
mango
</code></pre><p><strong>14)</strong> For the input file <code>sample.txt</code>, display from a line containing <code>it</code> till the next line number that is divisible by 3.<pre><code class=language-bash>$ sed -n '/it/,~3p' sample.txt
Just do-it
Believe it

banana
</code></pre><p><strong>15)</strong> Display only the odd numbered lines from <code>addr.txt</code>.<pre><code class=language-bash># can also use: sed -n '1~2p' addr.txt
$ sed -n 'p; n' addr.txt
Hello World
This game is good
12345
</code></pre><br><h1 id=breere-regular-expressions><a class=header href=#breere-regular-expressions>BRE/ERE Regular Expressions</a></h1><p><strong>1)</strong> For the input file <code>patterns.txt</code>, display all lines that start with <code>den</code> or end with <code>ly</code>.<pre><code class=language-bash>$ sed -nE '/^den|ly$/p' patterns.txt
2 lonely
dent
lovely
</code></pre><p><strong>2)</strong> For the input file <code>patterns.txt</code>, replace all occurrences of <code>42</code> with <code>[42]</code> unless it is at the edge of a word. Display only the modified lines.<pre><code class=language-bash>$ sed -n 's/\B42\B/[&]/gp' patterns.txt
Hi[42]Bye nice1[42]3 bad42
eqn2 = pressure*3+42/5-1[42]56
cool_[42]a 42fake
_[42]_
</code></pre><p><strong>3)</strong> For the input file <code>patterns.txt</code>, add <code>[]</code> around words starting with <code>s</code> and containing <code>e</code> and <code>t</code> in any order. Display only the modified lines.<pre><code class=language-bash>$ sed -nE 's/\bs\w*(e\w*t|t\w*e)\w*/[&]/gp' patterns.txt
[sets] tests Sauerkraut
[site] cite kite bite [store_2]
[subtle] sequoia
a [set]
</code></pre><p><strong>4)</strong> From the input file <code>patterns.txt</code>, display lines having the same first and last word character.<pre><code class=language-bash># can also use: sed -nE '/^(\w|(\w).*\2)$/p' patterns.txt
$ sed -nE '/^(\w)(.*\1)?$/p' patterns.txt
Not a pip DOWN
y
1 dentist 1
_42_
</code></pre><p><strong>5)</strong> For the input file <code>patterns.txt</code>, display lines containing <code>*[5]</code> literally.<pre><code class=language-bash>$ sed -n '/\*\[5]/p' patterns.txt
(9-2)*[5]
</code></pre><p><strong>6)</strong> <code>sed -nE '/\b[a-z](on|no)[a-z]\b/p'</code> is same as <code>sed -nE '/\b[a-z][on]{2}[a-z]\b/p'</code>. True or False? Sample input shown below might help to understand the differences, if any.<p>False. <code>[on]{2}</code> will also match <code>oo</code> and <code>nn</code>.<pre><code class=language-bash>$ printf 'known\nmood\nknow\npony\ninns\n'
known
mood
know
pony
inns
</code></pre><p><strong>7)</strong> For the input file <code>patterns.txt</code>, display all lines starting with <code>hand</code> and ending immediately with <code>s</code> or <code>y</code> or <code>le</code> or no further characters.<pre><code class=language-bash>$ sed -nE '/^hand([sy]|le)?$/p' patterns.txt
handle
handy
hands
hand
</code></pre><p><strong>8)</strong> For the input file <code>patterns.txt</code>, replace <code>42//5</code> or <code>42/5</code> with <code>8</code>. Display only the modified lines.<pre><code class=language-bash>$ sed -nE 's#42//?5#8#gp' patterns.txt
eqn3 = r*42-5/3+42///5-83+a
eqn1 = a+8-c
eqn2 = pressure*3+8-14256
</code></pre><p><strong>9)</strong> For the given quantifiers, what would be the equivalent form using the <code>{m,n}</code> representation?<ul><li><code>?</code> is same as <code>{,1}</code><li><code>*</code> is same as <code>{0,}</code><li><code>+</code> is same as <code>{1,}</code></ul><p><strong>10)</strong> In ERE, <code>(a*|b*)</code> is same as <code>(a|b)*</code> — True or False?<p>False. Because <code>(a*|b*)</code> will match only sequences like <code>a</code>, <code>aaa</code>, <code>bb</code>, <code>bbbbbbbb</code>. But <code>(a|b)*</code> can match a mixed sequence like <code>ababbba</code> too.<p><strong>11)</strong> For the input file <code>patterns.txt</code>, construct two different REGEXPs to get the outputs as shown below. Display only the modified lines.<pre><code class=language-bash># delete from '(' till next ')'
$ sed -n 's/([^)]*)//gp' patterns.txt
a/b + c%d
*[5]
def factorial
12- *4)
Hi there. Nice day

# delete from '(' till next ')' but not if there is '(' in between
$ sed -n 's/([^()]*)//gp' patterns.txt
a/b + c%d
*[5]
def factorial
12- (e+*4)
Hi there. Nice day(a
</code></pre><p><strong>12)</strong> For the input file <code>anchors.txt</code>, convert markdown anchors to corresponding hyperlinks as shown below.<pre><code class=language-bash>$ cat anchors.txt
# &LTa name="regular-expressions">&LT/a>Regular Expressions
## &LTa name="subexpression-calls">&LT/a>Subexpression calls
## &LTa name="the-dot-meta-character">&LT/a>The dot meta character

$ sed -E 's|[^"]+"([^"]+)">&LT/a>(.+)|[\2](#\1)|' anchors.txt
[Regular Expressions](#regular-expressions)
[Subexpression calls](#subexpression-calls)
[The dot meta character](#the-dot-meta-character)
</code></pre><p><strong>13)</strong> For the input file <code>patterns.txt</code>, replace the space character that occurs after a word ending with <code>a</code> or <code>r</code> with a newline character, only if the line also contains an uppercase letter. Display only the modified lines.<pre><code class=language-bash>$ sed -nE '/[A-Z]/ s/([ar])\b /\1\n/gp' patterns.txt
par
car
tar
far
Cart
Not a
pip DOWN
</code></pre><p><strong>14)</strong> Surround all whole words with <code>()</code>. Additionally, if the whole word is <code>imp</code> or <code>ant</code>, delete them. Can you do it with a single substitution?<pre><code class=language-bash>$ words='tiger imp goat eagle ant important'
$ echo "$words" | sed -E 's/\b(imp|ant|(\w+))\b/(\2)/g'
(tiger) () (goat) (eagle) () (important)
</code></pre><p><strong>15)</strong> For the input file <code>patterns.txt</code>, display lines containing <code>car</code> but not as a whole word.<pre><code class=language-bash>$ sed -nE '/\Bcar|car\B/p' patterns.txt
scar
care
a huge discarded pile of books
scare
part cart mart
</code></pre><p><strong>16)</strong> Will the ERE pattern <code>^a\w+([0-9]+:fig)?</code> match the same characters for the input <code>apple42:banana314</code> and <code>apple42:fig100</code>? If not, why not?<pre><code class=language-bash>$ echo 'apple42:banana314' | sed -E 's/^a\w+([0-9]+:fig)?/[&]/'
[apple42]:banana314

$ echo 'apple42:fig100' | sed -E 's/^a\w+([0-9]+:fig)?/[&]/'
[apple42:fig]100
</code></pre><p>For patterns matching from the same starting location, longest match wins in case of BRE/ERE flavors. So, <code>\w+</code> will give up characters to allow <code>([0-9]+:fig)?</code> to also match in the second case. In other flavors like PCRE, <code>apple42</code> will be matched for both the cases.<p><strong>17)</strong> For the input file <code>patterns.txt</code>, display lines starting with <code>4</code> or <code>-</code> or <code>u</code> or <code>sub</code> or <code>care</code>.<pre><code class=language-bash>$ sed -nE '/^([4u-]|sub|care)/p' patterns.txt
care
4*5]
-handy
subtle sequoia
unhand
</code></pre><p><strong>18)</strong> For the given input string, replace all occurrences of digit sequences with only the unique non-repeating sequence. For example, <code>232323</code> should be changed to <code>23</code> and <code>897897</code> should be changed to <code>897</code>. If there are no repeats (for example <code>1234</code>) or if the repeats end prematurely (for example <code>12121</code>), it should not be changed.<pre><code class=language-bash>$ s='1234 2323 453545354535 9339 11 60260260'
$ echo "$s" | sed -E 's/\b([0-9]+)\1+\b/\1/g'
1234 23 4535 9339 1 60260260
</code></pre><p><strong>19)</strong> Replace sequences made up of words separated by <code>:</code> or <code>.</code> by the first word of the sequence. Such sequences will end when <code>:</code> or <code>.</code> is not followed by a word character.<pre><code class=language-bash>$ ip='wow:Good:2_two.five: hi-2 bye kite.777:water.'
$ echo "$ip" | sed -E 's/([:.]\w*)+//g'
wow hi-2 bye kite
</code></pre><p><strong>20)</strong> Replace sequences made up of words separated by <code>:</code> or <code>.</code> by the last word of the sequence. Such sequences will end when <code>:</code> or <code>.</code> is not followed by a word character.<pre><code class=language-bash>$ ip='wow:Good:2_two.five: hi-2 bye kite.777:water.'
$ echo "$ip" | sed -E 's/((\w+)[:.])+/\2/g'
five hi-2 bye water
</code></pre><p><strong>21)</strong> Replace all whole words with <code>X</code> unless it is preceded by a <code>(</code> character.<pre><code class=language-bash>$ s='guava (apple) berry) apple (mango) (grape'
$ echo "$s" | sed -E 's/(^|[^(])\b\w+/\1X/g'
X (apple) X) X (mango) (grape
</code></pre><p><strong>22)</strong> Surround whole words with <code>[]</code> only if they are followed by <code>:</code> or <code>,</code> or <code>-</code>.<pre><code class=language-bash>$ ip='Poke,on=-=so_good:ink.to/is(vast)ever2-sit'
$ echo "$ip" | sed -E 's/(\w+)([:,-])/[\1]\2/g'
[Poke],on=-=[so_good]:ink.to/is(vast)[ever2]-sit
</code></pre><p><strong>23)</strong> The <code>fields.txt</code> file has fields separated by the <code>:</code> character. Delete <code>:</code> and the last field if there is a digit character anywhere before the last field.<pre><code class=language-bash>$ cat fields.txt
42:cat
twelve:a2b
we:be:he:0:a:b:bother
apple:banana-42:cherry:
dragon:unicorn:centaur

# can also use: sed -E '/[0-9].*:/ s/:[^:]*$//' fields.txt
$ sed -E 's/([0-9].*):.*/\1/' fields.txt
42
twelve:a2b
we:be:he:0:a:b
apple:banana-42:cherry
dragon:unicorn:centaur
</code></pre><p><strong>24)</strong> Are the commands <code>sed -n '/a^b/p'</code> and <code>sed -nE '/a^b/p'</code> equivalent?<p>They are not equivalent. In BRE, <code>^</code> is not special when not used in the customary position. In ERE, <code>^</code> has to be escaped to match it literally. The same holds true for the <code>$</code> metacharacter as well.<pre><code class=language-bash>$ echo 'a^b+c' | sed -n '/a^b/p'
a^b+c

$ echo 'a^b+c' | sed -nE '/a^b/p'
$ echo 'a^b+c' | sed -nE '/a\^b/p'
a^b+c
</code></pre><p><strong>25)</strong> What characters can be used as REGEXP delimiters?<p>Any character other than <code>\</code> and the newline character can be used as delimiters.</p><br><h1 id=flags><a class=header href=#flags>Flags</a></h1><p><strong>1)</strong> For the input file <code>para.txt</code>, remove all groups of lines marked with a line beginning with <code>start</code> and a line ending with <code>end</code>. Match both these markers case insensitively.<pre><code class=language-bash>$ cat para.txt
good start
Start working on that
project you always wanted
to, do not let it end
hi there
start and try to
finish the End
bye

$ sed '/^start/I,/end$/I d' para.txt
good start
hi there
bye
</code></pre><p><strong>2)</strong> The <code>headers.txt</code> file contains one header per line, starting with one or more <code>#</code> characters followed by one or more whitespace characters and then some words. Convert such lines to the corresponding output as shown below.<pre><code class=language-bash>$ cat headers.txt
# Regular Expressions
## Subexpression calls
## The dot meta character

$ sed -E 's/^#+\s+(.+)/\L\1/; y/ /-/' headers.txt
regular-expressions
subexpression-calls
the-dot-meta-character
</code></pre><p><strong>3)</strong> Using <code>para.txt</code>, create a file named <code>five.txt</code> with lines that contain a whole word of length <strong>5</strong> and a file named <code>seven.txt</code> with lines that contain a whole word of length <strong>7</strong>.<pre><code class=language-bash>$ sed -nE -e '/\b\w{5}\b/w five.txt' -e '/\b\w{7}\b/w seven.txt' para.txt

$ cat five.txt
good start
Start working on that
hi there
start and try to

$ cat seven.txt
Start working on that
project you always wanted
</code></pre><p><strong>4)</strong> Given sample strings have fields separated by <code>,</code> where field values can be empty as well. Use <code>sed</code> to replace the third field with <code>42</code>.<pre><code class=language-bash>$ echo 'lion,,ant,road,neon' | sed 's/[^,]*/42/3'
lion,,42,road,neon

$ echo ',,,' | sed 's/[^,]*/42/3'
,,42,
</code></pre><p><strong>5)</strong> Replace all occurrences of <code>e</code> with <code>3</code> except the first two matches.<pre><code class=language-bash>$ echo 'asset sets tests site' | sed 's/e/3/3g'
asset sets t3sts sit3

$ echo 'sample item teem eel' | sed 's/e/3/3g'
sample item t33m 33l
</code></pre><p><strong>6)</strong> For the input file <code>addr.txt</code>, replace all input lines with the number of characters in those lines. <code>wc -L</code> is one of the ways to get the length of a line as shown below. Assume that the input file doesn't have single or double quote characters.<pre><code class=language-bash># note that newline character isn't counted, which is preferable here
$ echo "Hello World" | wc -L
11

$ sed 's/.*/echo "&" | wc -L/e' addr.txt
11
11
17
14
5
13
</code></pre><p><strong>7)</strong> For the input file <code>para.txt</code>, assume that it'll always have lines in multiples of 4. Use <code>sed</code> commands such that there are 4 lines at a time in the pattern space. Then, delete from <code>start</code> till <code>end</code> provided <code>start</code> is matched only at the start of a line. Also, match these two keywords case insensitively.<pre><code class=language-bash>$ sed -E 'N;N;N; s/^start(\s|\S)*end//Im' para.txt
good start

hi there

bye
</code></pre><p><strong>8)</strong> For the input file <code>patterns.txt</code>, filter lines containing three or more occurrences of <code>ar</code>. For such lines, replace the third from last occurrence of <code>ar</code> with <code>X</code>.<pre><code class=language-bash>$ sed -nE 's/(.*)ar((.*ar){2})/\1X\2/p' patterns.txt
par car tX far Cart
pXt cart mart
</code></pre><p><strong>9)</strong> Display lines from <code>sample.txt</code> that satisfy both of these conditions:<ul><li><code>he</code> matched irrespective of case<li>either <code>World</code> or <code>Hi</code> matched case sensitively</ul><pre><code class=language-bash>$ sed -nE '/he/I{/World|Hi/p}' sample.txt
Hello World
Hi there
</code></pre><p><strong>10)</strong> For the input file <code>patterns.txt</code>, surround all hexadecimal sequences with a minimum of four characters with <code>[]</code>. Match <code>0x</code> as an optional prefix, but shouldn't be counted for determining the length. Match the characters case insensitively, and the sequences shouldn't be surrounded by other word characters. Display only the modified lines.<pre><code class=language-bash># can also use: sed -nE 's/\b(0x)?[[:xdigit:]]{4,}\b/[&]/Igp' patterns.txt
$ sed -nE 's/\b(0x)?[0-9a-f]{4,}\b/[&]/Igp' patterns.txt
"should not match [0XdeadBEEF]"
Hi42Bye nice1423 [bad42]
took 0xbad 22 [0x0ff1ce]
eqn2 = pressure*3+42/5-[14256]
</code></pre><br><h1 id=shell-substitutions><a class=header href=#shell-substitutions>Shell substitutions</a></h1><p><strong>1)</strong> Replace <code>#expr#</code> with the value of the <code>usr_ip</code> shell variable. Assume that this variable can only contain the metacharacters as shown in the sample below.<pre><code class=language-bash>$ usr_ip='c = (a/b) && (x-5)'
$ mod_ip=$(echo "$usr_ip" | sed 's|[/&]|\\&|g')
$ echo 'Expression: #expr#' | sed 's/#expr#/'"$mod_ip"'/'
Expression: c = (a/b) && (x-5)
</code></pre><p><strong>2)</strong> Repeat the previous exercise, but this time with command substitution instead of using a temporary variable.<pre><code class=language-bash>$ usr_ip='c = (a/b/y) && (x-5)'
$ echo 'Expression: #expr#' | sed 's/#expr#/'"$(echo "$usr_ip" | sed 's|[/&]|\\&|g')"'/'
Expression: c = (a/b/y) && (x-5)
</code></pre><br><h1 id=z-s-and-f-command-line-options><a class=header href=#z-s-and-f-command-line-options>z, s and f command line options</a></h1><p><strong>1)</strong> Replace any character other than word and <code>.</code> characters with the <code>_</code> character for the sample filenames shown below.<pre><code class=language-bash>$ mkdir test_dir && cd $_
$ touch 'file with spaces.txt' $'weird$ch\nars.txt' '!f@oo.txt'
# > at start of line indicates continuation of multiline shell command
$ for file in *; do
>   new_name=$(printf '%s' "$file" | sed -z 's/[^a-z0-9_.]/_/Ig')
>   mv "$file" "$new_name"
> done

$ ls
file_with_spaces.txt  _f_oo.txt  weird_ch_ars.txt
$ cd .. && rm -r test_dir
</code></pre><p><strong>2)</strong> Print only the third line, if any, from these input files: <code>addr.txt</code>, <code>para.txt</code> and <code>copyright.txt</code><pre><code class=language-bash>$ sed -sn '3p' addr.txt para.txt copyright.txt
This game is good
project you always wanted
bla bla bla
</code></pre><p><strong>3)</strong> For the input file <code>hex.txt</code>, use content from <code>replace.txt</code> to perform search and replace operations. Each line in <code>replace.txt</code> starts with the search term, followed by a space and then followed by the replace term. Assume that these terms do not contain any <code>sed</code> metacharacters.<pre><code class=language-bash>$ cat hex.txt
start address: 0xA0, func1 address: 0xA0
end address: 0xFF, func2 address: 0xB0
$ cat replace.txt
0xA0 0x5000
0xB0 0x6000
0xFF 0x7000

$ sed -f <(sed -E 's|(.+) (.+)|s/\1/\2/g|' replace.txt) hex.txt
start address: 0x5000, func1 address: 0x5000
end address: 0x7000, func2 address: 0x6000
</code></pre><p><strong>4)</strong> For the input file <code>nul_separated</code>, use the ASCII NUL character as the <em>line</em> separator and display lines containing <code>fig</code>. Also, change NUL characters in the output to the newline character.<pre><code class=language-bash>$ sed -zn '/fig/p' nul_separated | tr '\0' '\n'
apple
fig
mango
icecream
</code></pre><p><strong>5)</strong> For the input file <code>addr.txt</code>, change a newline character that comes before an uppercase letter to <code>.</code> followed by a space character. Assume that the input file doesn't have ASCII NUL characters.<pre><code class=language-bash>$ sed -zE 's/\n([A-Z])/. \1/g' addr.txt
Hello World. How are you. This game is good. Today is sunny
12345. You are funny
</code></pre><br><h1 id=append-change-insert><a class=header href=#append-change-insert>append, change, insert</a></h1><p><strong>1)</strong> For the input file <code>addr.txt</code>, display the third line surrounded by <code>-----</code>.<pre><code class=language-bash>$ sed -n -e '3 {i-----' -e 'p; a-----' -e '}' addr.txt
-----
This game is good
-----
</code></pre><p><strong>2)</strong> For the input file <code>addr.txt</code>, replace all lines starting from a line containing <code>you</code> till the end of file with a blank line followed by <code>Have a nice day</code>.<pre><code class=language-bash>$ sed '/you/,$ c\\nHave a nice day' addr.txt
Hello World

Have a nice day
</code></pre><p><strong>3)</strong> For the input file <code>addr.txt</code>, replace even numbered lines with <code>---</code>.<pre><code class=language-bash>$ sed 'n; c---' addr.txt
Hello World
---
This game is good
---
12345
---
</code></pre><br><h1 id=adding-content-from-file><a class=header href=#adding-content-from-file>Adding content from file</a></h1><p><strong>1)</strong> For the input file <code>addr.txt</code>, replace from the third to fifth lines with the second to fourth lines from <code>para.txt</code>.<pre><code class=language-bash>$ sed -n '2,4p' para.txt | sed -e '5r /dev/stdin' -e '3,5d' addr.txt
Hello World
How are you
Start working on that
project you always wanted
to, do not let it end
You are funny
</code></pre><p><strong>2)</strong> Add one line from <code>hex.txt</code> after every two lines of <code>copyright.txt</code>.<pre><code class=language-bash>$ sed 'n; R hex.txt' copyright.txt
bla bla 2015 bla
blah 2018 blah
start address: 0xA0, func1 address: 0xA0
bla bla bla
copyright: 2019
end address: 0xFF, func2 address: 0xB0
</code></pre><p><strong>3)</strong> For every line of the input file <code>hex.txt</code>, insert <code>---</code> before the line and append one line from <code>replace.txt</code> as shown below.<pre><code class=language-bash>$ sed -e 'R replace.txt' -e 'i---' hex.txt
---
start address: 0xA0, func1 address: 0xA0
0xA0 0x5000
---
end address: 0xFF, func2 address: 0xB0
0xB0 0x6000
</code></pre><p><strong>4)</strong> Insert the contents of <code>hex.txt</code> before a line matching <code>0x6000</code> of the input file <code>replace.txt</code>.<pre><code class=language-bash>$ sed '/0x6000/e cat hex.txt' replace.txt
0xA0 0x5000
start address: 0xA0, func1 address: 0xA0
end address: 0xFF, func2 address: 0xB0
0xB0 0x6000
0xFF 0x7000
</code></pre><p><strong>5)</strong> For the input file <code>addr.txt</code>, replace lines containing <code>are</code> with contents of <code>hex.txt</code>.<pre><code class=language-bash>$ sed -e '/are/r hex.txt' -e '//d' addr.txt
Hello World
start address: 0xA0, func1 address: 0xA0
end address: 0xFF, func2 address: 0xB0
This game is good
Today is sunny
12345
start address: 0xA0, func1 address: 0xA0
end address: 0xFF, func2 address: 0xB0
</code></pre><p><strong>6)</strong> The two commands shown below are equivalent. True or False?<pre><code class=language-bash>sed '/are/r pets.txt' addr.txt

cat pets.txt | sed '/are/r /dev/stdin' addr.txt
</code></pre><p>False. The first solution will append the contents of <code>pets.txt</code> for every line matching <code>are</code>. The second solution will append only once as the stdin data will not be available for subsequent matches.<p><strong>7)</strong> What do the commands <code>sed '0r file1' file2</code> and <code>sed '0R file1' file2</code> do?<p><code>sed '0r file1' file2</code> will insert the contents of <code>file1</code> before the first line of <code>file2</code>. The second command will produce an error since <code>0</code> as an address isn't supported for the <code>R</code> command.</p><br><h1 id=control-structures><a class=header href=#control-structures>Control structures</a></h1><p><strong>1)</strong> Using the input file <code>para.txt</code>, create a file named <code>markers.txt</code> with all lines that contain <code>start</code> or <code>end</code> (matched case insensitively) and a file named <code>rest.txt</code> with the remaining lines.<pre><code class=language-bash>$ sed -nE -e '/start|end/I{w markers.txt' -e 'b}' -e 'w rest.txt' para.txt

$ cat markers.txt
good start
Start working on that
to, do not let it end
start and try to
finish the End

$ cat rest.txt
project you always wanted
hi there
bye
</code></pre><p><strong>2)</strong> For the input file <code>addr.txt</code>:<ul><li>if a line contains <code>e</code>, surround all consecutive repeated characters with <code>{}</code> as well as uppercase those characters<li>else, if a line contains <code>u</code>, surround all uppercase letters in that line with <code>[]</code></ul><pre><code class=language-bash># note that H in the second line and Y in the last line aren't modified
$ sed -E '/e/ {s/(.)\1/{\U&}/g; b}; /u/ s/[A-Z]/[&]/g' addr.txt
He{LL}o World
How are you
This game is g{OO}d
[T]oday is sunny
12345
You are fu{NN}y
</code></pre><p><strong>3)</strong> The <code>nums.txt</code> file uses a space character as the field separator. The first field of some lines has one or more numbers separated by the <code>-</code> character. Surround such numbers in the first field with <code>[]</code> as shown below.<pre><code class=language-bash>$ cat nums.txt
123-87-593 42-3 fig
apple 42-42-42 1000 banana 4-3
53783-0913 hi 3 4-2
1000 guava mango

$ sed -E ':a s/^((\[[0-9]+\]-)*)?([0-9]+)/\1[\3]/; ta' nums.txt
[123]-[87]-[593] 42-3 fig
apple 42-42-42 1000 banana 4-3
[53783]-[0913] hi 3 4-2
[1000] guava mango
</code></pre><p><strong>4)</strong> Convert the contents of <code>headers.txt</code> such that it matches the content of <code>anchors.txt</code>. The input file <code>headers.txt</code> contains one header per line, starting with one or more <code>#</code> characters followed by a space character and then followed by the heading. You have to convert such headings into anchor tags as shown by the contents of <code>anchors.txt</code>. Save the output in <code>out.txt</code>.<pre><code class=language-bash>$ cat headers.txt
# Regular Expressions
## Subexpression calls
## The dot meta character
$ cat anchors.txt
# &LTa name="regular-expressions">&LT/a>Regular Expressions
## &LTa name="subexpression-calls">&LT/a>Subexpression calls
## &LTa name="the-dot-meta-character">&LT/a>The dot meta character

$ sed -E 's|\w.*|&LTa name="\L&\E">&LT/a>&|; :a s/("[^"]+) ([^"]+")/\1-\2/; ta' headers.txt > out.txt
$ diff -s out.txt anchors.txt
Files out.txt and anchors.txt are identical
</code></pre><p><strong>5)</strong> What is the difference between <code>t</code> and <code>T</code> commands?<p>Any successful substitution triggers the <code>t</code> command. <code>T</code> is triggered only if all the prior substitutions have failed.<p><strong>6)</strong> The <code>blocks.txt</code> file uses <code>%=%=</code> to separate group of lines. Display the first such group.<pre><code class=language-bash>$ cat blocks.txt
%=%=
apple
banana
%=%=
3.14
42
1000
%=%=
brown
green
%=%=
hi
hello there
bye

$ sed ':a n; /%=%=/Q; ba' blocks.txt
%=%=
apple
banana
</code></pre><br><h1 id=processing-lines-bounded-by-distinct-markers><a class=header href=#processing-lines-bounded-by-distinct-markers>Processing lines bounded by distinct markers</a></h1><p><strong>1)</strong> The <code>blocks.txt</code> file uses <code>%=%=</code> to separate group of lines. Display the last such group.<pre><code class=language-bash>$ tac blocks.txt | sed '/%=%=/q' | tac
%=%=
hi
hello there
bye
</code></pre><p><strong>2)</strong> The <code>code.txt</code> file has code snippets that are surrounded by whole lines containing <code>%%Code: python%%</code> and <code>%%end%%</code>. The end of such snippets is always followed by an empty line. Assume that there will always be at least one line of code between the markers. Delete all such code snippets as well as the empty line that follows.<pre><code class=language-bash>$ sed '/^%%Code: python%%$/,/^%%end%%$/{//N; d}' code.txt
H1: Introduction

REPL is a good way to learn Python for beginners.

H2: String methods

Python comes loaded with awesome methods.
Enjoy learning Python.

</code></pre><p><strong>3)</strong> The <code>code.txt</code> file has code snippets that are surrounded by whole lines containing <code>%%Code: python%%</code> and <code>%%end%%</code>. Display the lines between such markers only for the first block.<pre><code class=language-bash>$ sed -n '/^%%Code: python%%$/,/^%%end%%$/{//!p; /^%%end%%$/q}' code.txt
>>> 3 + 7
10
>>> 22 / 7
3.142857142857143
>>> 22 // 7
3
</code></pre><p><strong>4)</strong> The input file <code>broken.txt</code> starts with a line containing <code>top</code> followed by some content before a line containing <code>bottom</code> is found. Blocks of lines bounded by these two markers repeats except for the last block as it is missing the <code>bottom</code> marker. The first <code>sed</code> command shown below doesn't work because it is matching till the end of file due to the missing marker. Correct this command to get the expected output shown below.<pre><code class=language-bash>$ cat broken.txt
--top--
3.14
[bottom]
--top--
1234567890
[bottom]
--top--
Hi there
Have a nice day
Good bye

# wrong output
$ sed -n '/top/,/bottom/ {//!p}' broken.txt
3.14
1234567890
Hi there
Have a nice day
Good bye

# expected output
$ tac broken.txt | sed -n '/bottom/,/top/ {//!p}' | tac
3.14
1234567890
</code></pre><p><strong>5)</strong> For the input file <code>addr.txt</code>, replace the lines occurring between the markers <code>How</code> and <code>12345</code> with the contents of the file <code>hex.txt</code>.<pre><code class=language-bash>$ sed -e '/How/r hex.txt' -e '//,/12345/{//!d}' addr.txt
Hello World
How are you
start address: 0xA0, func1 address: 0xA0
end address: 0xFF, func2 address: 0xB0
12345
You are funny
</code></pre></main><nav aria-label="Page navigation"class=nav-wrapper><a aria-label="Previous chapter"class="mobile-nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=further-reading.html rel=prev> <i class="fa fa-angle-left"></i> </a><div style="clear: both"></div></nav></div></div><nav aria-label="Page navigation"class=nav-wide-wrapper><a aria-label="Previous chapter"class="nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=further-reading.html rel=prev> <i class="fa fa-angle-left"></i> </a></nav></div><script>window.playground_copyable = true;</script><script charset=utf-8 src=elasticlunr.min.js></script><script charset=utf-8 src=mark.min.js></script><script charset=utf-8 src=searcher.js></script><script charset=utf-8 src=clipboard.min.js></script><script charset=utf-8 src=highlight.js></script><script charset=utf-8 src=book.js></script><script src=sidebar.js></script>